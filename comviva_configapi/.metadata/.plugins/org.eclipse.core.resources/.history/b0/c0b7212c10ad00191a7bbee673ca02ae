/** 
 * COPYRIGHT: Comviva Technologies Pvt. Ltd.
 * This software is the sole property of Comviva
 * and is protected by copyright law and international
 * treaty provisions. Unauthorized reproduction or
 * redistribution of this program, or any portion of
 * it may result in severe civil and criminal penalties
 * and will be prosecuted to the maximum extent possible
 * under the law. Comviva reserves all rights not
 * expressly granted. You may not reverse engineer, decompile,
 * or disassemble the software, except and only to the
 * extent that such activity is expressly permitted
 * by applicable law notwithstanding this limitation.
 * THIS SOFTWARE IS PROVIDED TO YOU "AS IS" WITHOUT
 * WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR PURPOSE.
 * YOU ASSUME THE ENTIRE RISK AS TO THE ACCURACY
 * AND THE USE OF THIS SOFTWARE. Comviva SHALL NOT BE LIABLE FOR
 * ANY DAMAGES WHATSOEVER ARISING OUT OF THE USE OF OR INABILITY TO
 * USE THIS SOFTWARE, EVEN IF Comviva HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 **/
package com.comviva.mfs.service.domain;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Service;

import com.comviva.mfs.common.Constants;
import com.comviva.mfs.common.ErrorCodes;
import com.comviva.mfs.common.MessageCodes;
import com.comviva.mfs.common.ServiceRoleCodes;
import com.comviva.mfs.common.ValidationException;
import com.comviva.mfs.common.utils.CommonUtils;
import com.comviva.mfs.entity.CategoryChecker;
import com.comviva.mfs.entity.DomainChecker;
import com.comviva.mfs.entity.DomainMaker;
import com.comviva.mfs.model.domain.DeleteDomainInitiateRequest;
import com.comviva.mfs.model.domain.DeleteDomainInitiateResponse;
import com.comviva.mfs.repository.CategoryCheckerRepository;
import com.comviva.mfs.repository.DomainCheckerRepository;
import com.comviva.mfs.repository.DomainMakerRepository;
import com.comviva.mfs.service.CommonService;

/**
 * This service used for Delete Domain Initiate
 * 
 * @author sudharshans
 */
@Service
@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class DeleteDomainInitiateService extends CommonService {

    private DomainChecker domainChecker;
    private DomainMaker domainMaker;
    private DomainCheckerRepository domainCheckerRepository;
    private DomainMakerRepository domainMakerRepository;
    private String domainCode;
    private DeleteDomainInitiateRequest deleteDomainInitiateRequest;
    private CategoryCheckerRepository categoryCheckerRepository;

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;

    /**
     * Construct DeleteDomainInitiateService
     * 
     * @param domainCheckerRepository
     *            - domainCheckerRepository
     * @param domainMakerRepository
     *            - domainMakerRepository
     * @param categoryCheckerRepository
     *            - categoryCheckerRepository
     */
    @Autowired
    public DeleteDomainInitiateService(DomainCheckerRepository domainCheckerRepository,
            DomainMakerRepository domainMakerRepository, CategoryCheckerRepository categoryCheckerRepository) {
        this.domainCheckerRepository = domainCheckerRepository;
        this.domainMakerRepository = domainMakerRepository;
        this.categoryCheckerRepository = categoryCheckerRepository;
    }

    /**
     * Delete DomainInitiate
     * 
     * @param domainCode
     *            - String
     * @param deleteDomainInitiateRequest
     *            - deleteDomainInitiateRequest
     * @return DeleteDomainInitiateResponse
     */
    public DeleteDomainInitiateResponse execute(String domainCode,
            DeleteDomainInitiateRequest deleteDomainInitiateRequest) {
        Map<String, Object> constructAdminMap = new HashMap<>();
        List<String> params = new ArrayList<>();
        String isApprovalRequired;
        this.domainCode = domainCode;
        this.deleteDomainInitiateRequest = deleteDomainInitiateRequest;
        serviceRoleCode = ServiceRoleCodes.DELETE_DOMAIN_INIT_ROLE.getStrValue();
        super.initiate(deleteDomainInitiateRequest, serviceRoleCode);
        isApprovalRequired = deleteDomainInitiateRequest.getIsApprovalRequired();
        validateInputs();
        if (Constants.ACTIVE_STATUS.getStrValue().equals(isApprovalRequired)) {
            createMakerData();
            domainMakerRepository.save(domainMaker);
            constructAdminMap.put(NEW_OBJECT, domainMaker);
            constructAdminMap.put(OLD_OBJECT, domainChecker);
            params.add(domainMaker.getDomainName());
            responseMessageCode = MessageCodes.DOMAIN_DELETE_INIT_SUCCESS.getStrValue();
        } else {
            constructAdminMap.put(OLD_OBJECT, domainChecker);
            createCheckerData();
            domainCheckerRepository.save(domainChecker);
            params.add(domainChecker.getDomainName());
            responseMessageCode = MessageCodes.DOMAIN_DELETE_APPR_SUCCESS.getStrValue();
            constructAdminMap.put(NEW_OBJECT, domainChecker);
            kafkaTemplate.send("domainChecker", domainChecker);
        }
        responseStatus = Constants.SUCCESS_RESPONSE.getStrValue();
        createRequestResponseHistObject();
        createAuditLogMap(constructAdminMap);
        generateReponseMessage(params);
        return createResponse();
    }

    private void createMakerData() {
        domainMaker = new DomainMaker();
        copyObjects(domainMaker, domainChecker);
        domainMaker.setStatus(Constants.DELETE_INITIATE_STATUS.getStrValue());
    }

    private void createCheckerData() {
        domainChecker.setStatus(Constants.INACTIVE_STATUS.getStrValue());
    }

    /**
     * Validate the request parameters
     */
    @Override
    public void validateInputs() {
        domainChecker = domainCheckerRepository.getDomainByDomainCode(Constants.YES.getStrValue(), domainCode);
        if (null == domainChecker) {
            throw new ValidationException(domainCode, ErrorCodes.DOMAIN_CODE_NOT_FOUND.getErrorCode());
        }
        domainMaker = domainMakerRepository.getDomainByDomainCode(Constants.DELETE_INITIATE_STATUS.getStrValue(),
                domainCode);
        if (null != domainMaker) {
            throw new ValidationException(domainCode, ErrorCodes.DOMAIN_CODE_NOT_DELETE_INITIATED.getErrorCode());
        }
        List<CategoryChecker> categoryList = categoryCheckerRepository
                .findCategoryListByDomainCode(Constants.YES.getStrValue(), domainCode);
        if (!CommonUtils.isNullorEmpty(categoryList)) {
            throw new ValidationException(domainCode, ErrorCodes.DOMAIN_HAVE_ASSIGNED_CATEGORIES.getErrorCode());
        }
        if (CommonUtils.isNullorEmpty(deleteDomainInitiateRequest.getIsApprovalRequired())) {
            throw new ValidationException(Constants.IS_APPROVE.getStrValue(),
                    MessageCodes.FIELD_MANDATORY.getStrValue());
        } else if (!CommonUtils.isApprovalRequired(deleteDomainInitiateRequest.getIsApprovalRequired())) {
            throw new ValidationException(Constants.IS_APPROVE.getStrValue(), MessageCodes.FIELD_INVALID.getStrValue());
        }
    }

    /**
     * Construct the DeleteDomainInitiateResponse
     * 
     * return DeleteDomainInitiateResponse
     */

    @Override
    public DeleteDomainInitiateResponse createResponse() {
        DeleteDomainInitiateResponse deleteInitiateDomainResponse = new DeleteDomainInitiateResponse();
        deleteInitiateDomainResponse.setStatus(responseStatus);
        deleteInitiateDomainResponse.setExternalRefId(deleteDomainInitiateRequest.getExternalRefId());
        deleteInitiateDomainResponse.setReferenceId(referenceId);
        deleteInitiateDomainResponse.setMessage(responseMessage);
        return deleteInitiateDomainResponse;
    }

}
