<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>HttpClientConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">interop-transaction-engine</a> &gt; <a href="index.source.html" class="el_package">com.comviva.interop.txnengine.configuration</a> &gt; <span class="el_source">HttpClientConfig.java</span></div><h1>HttpClientConfig.java</h1><pre class="source lang-java linenums">package com.comviva.interop.txnengine.configuration;

import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

import org.apache.http.HeaderElement;
import org.apache.http.HeaderElementIterator;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.config.Registry;
import org.apache.http.config.RegistryBuilder;
import org.apache.http.conn.ConnectionKeepAliveStrategy;
import org.apache.http.conn.socket.ConnectionSocketFactory;
import org.apache.http.conn.socket.PlainConnectionSocketFactory;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;
import org.apache.http.message.BasicHeaderElementIterator;
import org.apache.http.protocol.HTTP;
import org.apache.http.ssl.SSLContextBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.EnableScheduling;

import com.comviva.interop.txnengine.enums.LogConstants;
import com.comviva.interop.txnengine.services.IdleConnectionMonitorThread;
import com.comviva.interop.txnengine.util.LoggerUtil;

/**
 * - Supports both HTTP and HTTPS - Uses a connection pool to re-use connections
 * and save overhead of creating connections. - Has a custom connection
 * keep-alive strategy (to apply a default keep-alive if one isn't specified) -
 * Starts an idle connection monitor to continuously clean up stale connections.
 */
@Configuration
@EnableScheduling
public class HttpClientConfig {

<span class="fc" id="L47">    private static final Logger LOGGER = LoggerFactory.getLogger(HttpClientConfig.class);</span>
    private HttpClientProperties httpClientProperties;
    private static final String TIMEOUT = &quot;timeout&quot;;
    private static final int TIMEOUT_MULTIPLIER = 1000;

    @Autowired
<span class="fc" id="L53">    public HttpClientConfig(HttpClientProperties httpClientProperties) {</span>
<span class="fc" id="L54">        this.httpClientProperties = httpClientProperties;</span>
<span class="fc" id="L55">    }</span>

    @Bean
    public PoolingHttpClientConnectionManager poolingConnectionManager() {
<span class="fc" id="L59">        SSLContextBuilder builder = new SSLContextBuilder();</span>
        try {
<span class="fc" id="L61">            builder.loadTrustMaterial(null, new TrustSelfSignedStrategy());</span>
<span class="nc" id="L62">        } catch (NoSuchAlgorithmException | KeyStoreException e) {</span>
<span class="nc" id="L63">            String message = LoggerUtil.printLog(LogConstants.HTTP_CLIENT_CONFIGURATION_EVENT.getValue(), e);</span>
<span class="nc" id="L64">            LOGGER.info(&quot;Pooling Connection Manager Initialisation failure because of due to NoSuchAlgorithmException | KeyStoreException {}&quot; ,message);</span>
<span class="fc" id="L65">        }</span>

<span class="fc" id="L67">        SSLConnectionSocketFactory sslsf = null;</span>
        try {
<span class="fc" id="L69">            sslsf = new SSLConnectionSocketFactory(builder.build());</span>
<span class="nc" id="L70">        } catch (KeyManagementException | NoSuchAlgorithmException e) {</span>
<span class="nc" id="L71">            String message = LoggerUtil.printLog(LogConstants.HTTP_CLIENT_CONFIGURATION_EVENT.getValue(), e);</span>
<span class="nc" id="L72">            LOGGER.info(&quot;Pooling Connection Manager Initialisation failure because of due to NoSuchAlgorithmException | KeyStoreException {}&quot; ,message);</span>
<span class="fc" id="L73">        }</span>

<span class="fc" id="L75">        Registry&lt;ConnectionSocketFactory&gt; socketFactoryRegistry = RegistryBuilder.&lt;ConnectionSocketFactory&gt;create()</span>
<span class="fc" id="L76">                .register(&quot;https&quot;, sslsf).register(&quot;http&quot;, new PlainConnectionSocketFactory()).build();</span>

<span class="fc" id="L78">        PoolingHttpClientConnectionManager poolingConnectionManager = new PoolingHttpClientConnectionManager(</span>
                socketFactoryRegistry);
<span class="fc" id="L80">        poolingConnectionManager.setMaxTotal(httpClientProperties.getHttpMaxTotalConnections());</span>
<span class="fc" id="L81">        return poolingConnectionManager;</span>
    }

    @Bean
    public ConnectionKeepAliveStrategy connectionKeepAliveStrategy() {
<span class="fc" id="L86">        return (response, context) -&gt; {</span>
<span class="fc" id="L87">            HeaderElementIterator it = new BasicHeaderElementIterator(response.headerIterator(HTTP.CONN_KEEP_ALIVE));</span>
<span class="pc bpc" id="L88" title="1 of 2 branches missed.">            while (it.hasNext()) {</span>
<span class="nc" id="L89">                HeaderElement he = it.nextElement();</span>
<span class="nc" id="L90">                String param = he.getName();</span>
<span class="nc" id="L91">                String value = he.getValue();</span>

<span class="nc bnc" id="L93" title="All 4 branches missed.">                if (value != null &amp;&amp; TIMEOUT.equalsIgnoreCase(param)) {</span>
<span class="nc" id="L94">                    return Long.parseLong(value) * TIMEOUT_MULTIPLIER;</span>
                }
<span class="nc" id="L96">            }</span>
<span class="fc" id="L97">            return httpClientProperties.getHttpDefaultKeepAliveTimeMillis();</span>
        };
    }

    @Bean
    public CloseableHttpClient httpClient() {
<span class="fc" id="L103">        RequestConfig requestConfig = RequestConfig.custom()</span>
<span class="fc" id="L104">                .setConnectionRequestTimeout(httpClientProperties.getHttpRequestTimeout())</span>
<span class="fc" id="L105">                .setConnectTimeout(httpClientProperties.getHttpConnectTimeout()).setSocketTimeout(httpClientProperties.getHttpSocketTimeout())</span>
<span class="fc" id="L106">                .build();</span>

<span class="fc" id="L108">        return HttpClients.custom().setDefaultRequestConfig(requestConfig)</span>
<span class="fc" id="L109">                .setConnectionManager(poolingConnectionManager()).setKeepAliveStrategy(connectionKeepAliveStrategy())</span>
<span class="fc" id="L110">                .build();</span>
    }

    @Bean
    public IdleConnectionMonitorThread idleConnectionMonitor(final PoolingHttpClientConnectionManager connectionManager) {
<span class="fc" id="L115">        ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();</span>
<span class="fc" id="L116">        IdleConnectionMonitorThread idelConnectionMonitorServiceThread = new IdleConnectionMonitorThread(httpClientProperties, connectionManager);</span>
<span class="fc" id="L117">        scheduledExecutorService.scheduleAtFixedRate(idelConnectionMonitorServiceThread, httpClientProperties.getInitialDelay(),</span>
<span class="fc" id="L118">                httpClientProperties.getIdleConnectionMonitorFixedDelay(), TimeUnit.MILLISECONDS);</span>
<span class="fc" id="L119">        return idelConnectionMonitorServiceThread;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>