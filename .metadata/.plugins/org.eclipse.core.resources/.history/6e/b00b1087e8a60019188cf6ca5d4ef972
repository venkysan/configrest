package com.comviva.mfs.service.domain;

import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.apache.commons.beanutils.BeanUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.config.ConfigurableBeanFactory;
import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Service;

import com.comviva.mfs.common.Constants;
import com.comviva.mfs.common.ErrorCodes;
import com.comviva.mfs.common.ServiceRoleCodes;
import com.comviva.mfs.common.ValidationException;
import com.comviva.mfs.common.utils.CommonUtils;
import com.comviva.mfs.entity.CategoryChecker;
import com.comviva.mfs.entity.DomainChecker;
import com.comviva.mfs.entity.DomainMaker;
import com.comviva.mfs.model.domain.DeleteDomainInitiateRequest;
import com.comviva.mfs.model.domain.DeleteDomainInitiateResponse;
import com.comviva.mfs.repository.CategoryCheckerRepository;
import com.comviva.mfs.repository.DomainCheckerRepository;
import com.comviva.mfs.repository.DomainMakerRepository;
import com.comviva.mfs.service.CommonService;

@Service
@Scope(scopeName = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class DeleteDomainInitiateService extends CommonService {

	private DomainChecker domainChecker;
	private DomainMaker domainMaker;
	private DomainCheckerRepository domainCheckerRepository;
	private DomainMakerRepository domainMakerRepository;
	private String domainCode;
	private DeleteDomainInitiateRequest deleteDomainInitiateRequest;
	private CategoryCheckerRepository categoryCheckerRepository;

	@Autowired
	public DeleteDomainInitiateService(DomainCheckerRepository domainCheckerRepository,
			DomainMakerRepository domainMakerRepository, CategoryCheckerRepository categoryCheckerRepository) {
		this.domainCheckerRepository = domainCheckerRepository;
		this.domainMakerRepository = domainMakerRepository;
		this.categoryCheckerRepository = categoryCheckerRepository;
	}

	public DeleteDomainInitiateResponse execute(String domainCode,
			DeleteDomainInitiateRequest deleteDomainInitiateRequest) {
		Map<String, Object> constructAdminMap = new HashMap<>();
		List<String> params = new ArrayList<>();
		String isApprovalRequired;
		try {
			this.domainCode = domainCode;
			this.deleteDomainInitiateRequest = deleteDomainInitiateRequest;
			serviceRoleCode = ServiceRoleCodes.DELETE_DOMAIN_INIT_ROLE.getStrValue();
			super.execute(deleteDomainInitiateRequest, serviceRoleCode);
			isApprovalRequired = deleteDomainInitiateRequest.getIsApprovalRequired();
			validateInputs();
			if (null != isApprovalRequired && Constants.ACTIVE_STATUS.getStrValue().equals(isApprovalRequired)) {
				createMakerData();
				domainMakerRepository.initiateDomain(domainMaker);
				constructAdminMap.put("newObject", domainMaker);
				constructAdminMap.put("oldObject", domainChecker);
				params.add(domainMaker.getDomainName());
			} else {
				constructAdminMap.put("oldObject", domainChecker);
				createCheckerData();
				domainCheckerRepository.approveDomain(domainChecker);
				params.add(domainChecker.getDomainName());
				constructAdminMap.put("newObject", domainChecker);
			}
			responseStatus = Constants.SUCCESS_RESPONSE.getStrValue();
			createRequestResponseHistObject();
			createAuditLogMap(constructAdminMap);
		} catch (Exception e) {
			handleException(e, params, this.getClass().getSimpleName());
		}
		generateReponseMessage(params);
		return createResponse();
	}

	private void createMakerData() throws InvocationTargetException, IllegalAccessException {
		domainMaker = new DomainMaker();
		BeanUtils.copyProperties(domainMaker, domainChecker);
		domainMaker.setStatus(Constants.DELETE_INITIATE_STATUS.getStrValue());
	}

	private void createCheckerData() {
		domainChecker.setStatus(Constants.INACTIVE_STATUS.getStrValue());
	}

	@Override
	public void validateInputs() {
		domainChecker = domainCheckerRepository.getDomainByDomainCode(domainCode);
		if (null == domainChecker) {
			throw new ValidationException(domainCode, ErrorCodes.DOMAIN_CODE_NOT_FOUND.getErrorCode());
		}
		domainMaker = domainMakerRepository.getDomainByDomainCode(domainCode);
		if (null != domainMaker) {
			throw new ValidationException(domainCode, ErrorCodes.DOMAIN_CODE_INITIATED.getErrorCode());
		}
		List<CategoryChecker> categoryList = categoryCheckerRepository
				.findCategoryListByDomainCode(Constants.YES.getStrValue(), domainCode);
		if (!CommonUtils.isNullorEmpty(categoryList)) {
			throw new ValidationException(domainCode, ErrorCodes.DOMAIN_HAVE_ASSIGNED_CATEGORIES.getErrorCode());
		}
	}

	@Override
	public DeleteDomainInitiateResponse createResponse() {
		DeleteDomainInitiateResponse deleteInitiateDomainResponse = new DeleteDomainInitiateResponse();
		deleteInitiateDomainResponse.setStatus(responseStatus);
		deleteInitiateDomainResponse.setExternalRefId(deleteDomainInitiateRequest.getExternalRefId());
		deleteInitiateDomainResponse.setReferenceId(referenceId);
		deleteInitiateDomainResponse.setMessage(responseMessage);
		return deleteInitiateDomainResponse;
	}

}
